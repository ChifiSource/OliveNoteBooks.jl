{"cells":{"5":{"5":{"outputs":{"output_type":"execute_result","data":{"text/plain":["accuracy (generic function with 1 method)"]},"metadata":{},"execution_count":5},"cell_type":"code","source":["function accuracy(model::AbstractModel, testx::Vector{&lt;:Any}, testy::Vector{&lt;:Any})\n    yhat::Vector{&lt;:Any} = predict(model, testx)\n    bitmask::Vector{Bool} = [begin \n        if x == y \n           true\n        else \n           false\n        end\n    end for (x, y) in zip(yhat, testy)]\n    (length(bitmask) / length(findall(x -&gt; x, bitmask)))::Real\nend"],"metadata":{},"execution_count":5}},"7":{"7":{"outputs":{"output_type":"execute_result","data":{"text/plain":[""]},"metadata":{},"execution_count":7},"cell_type":"code","source":["abstract type MajorityClass &lt;: Categorical end\n\nabstract type MeanBaseline &lt;: Continuous end"],"metadata":{},"execution_count":7}},"12":{"12":{"outputs":{"output_type":"execute_result","data":{"text/plain":["Main.ehhXpfXcle.Model{Main.ehhXpfXcle.MeanBaseline}(Dict{String, Any}())"]},"metadata":{},"execution_count":12},"cell_type":"code","source":["mymodel = MeanBaseline()"],"metadata":{},"execution_count":12}},"8":{"8":{"outputs":{"output_type":"execute_result","data":{"text/plain":["Main.ehhXpfXcle.MeanBaseline\u0000\u0000\u0000\u0000"]},"metadata":{},"execution_count":8},"cell_type":"code","source":["MajorityClass() = Model{MajorityClass}()\nMeanBaseline() = Model{MeanBaseline}()"],"metadata":{},"execution_count":8}},"1":{"1":{"outputs":{"output_type":"execute_result","data":{"text/plain":[""]},"metadata":{},"execution_count":1},"cell_type":"markdown","source":["# parameter abstraction\nJulia uses multiple dispatch to facilitate **abstraction** -- a vital generic programming concept which allows for the writing of generic methods to \nfacilitate many types. With Julia, things are also taken a step further -- the language also allows us to apply the same abstraction to parameters.\n"],"metadata":{},"execution_count":1}},"4":{"4":{"outputs":{"output_type":"execute_result","data":{"text/plain":[""]},"metadata":{},"execution_count":4},"cell_type":"code","source":["abstract type AbstractModel end\n\nmutable struct Model{T &lt;: Any} &lt;: AbstractModel\n    data::Dict{String, Any}\n    Model{T}() where {T &lt;: ModelType} = new{T}(Dict{String, Any}())\nend"],"metadata":{},"execution_count":4}},"6":{"6":{"outputs":{"output_type":"execute_result","data":{"text/plain":["accuracy (generic function with 2 methods)"]},"metadata":{},"execution_count":6},"cell_type":"code","source":["function accuracy(model::Model{&lt;:Continuous}, testx::Vector{&lt;:Any}, testy::Vector{&lt;:Any})\n    yhat::Vector{&lt;:Any} = predict(model, testx)\n    (cor(yhat, testy) ^ 2)::Number\nend"],"metadata":{},"execution_count":6}},"13":{"13":{"outputs":{"output_type":"execute_result","data":{"text/plain":["Dict{String, Any} with 1 entry:\n  \"mu\" => 4.71429"]},"metadata":{},"execution_count":13},"cell_type":"code","source":["fit!(mymodel, trainx, trainy)\n"],"metadata":{},"execution_count":13}},"2":{"2":{"outputs":{"output_type":"execute_result","data":{"text/plain":[""]},"metadata":{},"execution_count":2},"cell_type":"code","source":["using Statistics"],"metadata":{},"execution_count":2}},"10":{"10":{"outputs":{"output_type":"execute_result","data":{"text/plain":["predict (generic function with 1 method)"]},"metadata":{},"execution_count":10},"cell_type":"code","source":["predict(model::Model{MeanBaseline}, testx) = begin\n    if ~(\"mu\" in keys(model.data))\n        throw(\"this model has not been fitted to data yet. Use `fit!` first.\")\n    end\n    mean::Real = model.data[\"mu\"]\n    [mean for x in testx]::Vector{&lt;:Any}\nend"],"metadata":{},"execution_count":10}},"11":{"11":{"outputs":{"output_type":"execute_result","data":{"text/plain":["4-element Vector{Int64}:\n 5\n 7\n 4\n 4"]},"metadata":{},"execution_count":11},"cell_type":"code","source":["trainx = [5, 5, 6, 2, 3, 7, 5]\ntrainy = [5, 8, 4, 3, 3, 4, 6]\ntestx = [5, 6, 3, 4]\ntesty = [5, 7, 4, 4]"],"metadata":{},"execution_count":11}},"9":{"9":{"outputs":{"output_type":"execute_result","data":{"text/plain":["fit! (generic function with 1 method)"]},"metadata":{},"execution_count":9},"cell_type":"code","source":["function fit!(model::Model{MeanBaseline}, trainx::Vector{&lt;:Any}, trainy::Vector{&lt;:Any})\n    push!(model.data, \"mu\" =&gt; Float64(sum(trainy) / length(trainy)))\nend"],"metadata":{},"execution_count":9}},"15":{"15":{"outputs":{"output_type":"execute_result","data":{"text/plain":["\"this model has not been fitted to data yet. Use `fit!` first.\""]},"metadata":{},"execution_count":15},"cell_type":"code","source":["accuracy(mymodel, testx, testy)"],"metadata":{},"execution_count":15}},"14":{"14":{"outputs":{"output_type":"execute_result","data":{"text/plain":["4-element Vector{Float64}:\n 4.714285714285714\n 4.714285714285714\n 4.714285714285714\n 4.714285714285714"]},"metadata":{},"execution_count":14},"cell_type":"code","source":["predict(mymodel, testx)\n"],"metadata":{},"execution_count":14}},"3":{"3":{"outputs":{"output_type":"execute_result","data":{"text/plain":[""]},"metadata":{},"execution_count":3},"cell_type":"code","source":["abstract type ModelType end\n\nabstract type Categorical &lt;: ModelType end\n\nabstract type Classifier &lt;: Categorical end\n\nabstract type Continuous &lt;: ModelType end"],"metadata":{},"execution_count":3}}},"nbformat_minor":4,"metadata":{"language_info":{"file_extension":".jl","mimetype":"application/julia","name":"julia","version":"1.9.2"},"kernelspec":{"name":"julia-SubString{String}[\"1\", \"9\"]","display_name":"Julia 1.9.2","language":"julia"}},"nbformat":4}